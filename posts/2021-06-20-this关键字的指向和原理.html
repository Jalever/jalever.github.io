<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><link rel="preload" as="font" href="/_next/static/media/a34f9d1faa5f3315-s.p.woff2" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/3e50223f751b8206.css" data-precedence="next"/><title>2021-06-20-this关键字的指向和原理</title><meta name="description" content="这篇文章深入探讨了 JavaScript 中 this 关键字的指向原理及其在不同调用环境中的行为。"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="any"/><meta name="next-size-adjust"/><script src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js" noModule=""></script></head><body class="antialiased min-h-screen bg-white dark:bg-slate-950 text-slate-900 dark:text-slate-50 __className_a184c8"><script>!function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');var e=localStorage.getItem('theme');if('system'===e||(!e&&true)){var t='(prefers-color-scheme: dark)',m=window.matchMedia(t);if(m.media!==t||m.matches){d.style.colorScheme = 'dark';c.add('dark')}else{d.style.colorScheme = 'light';c.add('light')}}else if(e){c.add(e|| '')}if(e==='light'||e==='dark')d.style.colorScheme=e}catch(e){}}()</script><div class="max-w-2xl mx-auto py-10 px-4"><header><div class="flex items-center justify-between"><button class="border rounded-md w-6 h-6 flex items-center justify-center"><span class="sr-only">Toggle mode</span><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4"><path stroke-linecap="round" stroke-linejoin="round" d="M21.752 15.002A9.718 9.718 0 0118 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 003 11.25C3 16.635 7.365 21 12.75 21a9.753 9.753 0 009.002-5.998z"></path></svg></button><nav class="ml-auto text-sm font-medium space-x-6"><a href="/">Home</a><a href="/about">About</a></nav></div></header><main><article class="py-6 prose dark:prose-invert"><h1 class="mb-2">2021-06-20-this关键字的指向和原理</h1><p class="text-xl mt-0 text-slate-700 dark:text-slate-200">这篇文章深入探讨了 JavaScript 中 this 关键字的指向原理及其在不同调用环境中的行为。</p><hr class="my-4"/><h1>this 关键字的指向和原理</h1>
<h1>定义</h1>
<p><strong>this</strong>是<strong>JavaScript</strong>中的关键字，它隐式的传递了一个对象引用，可以理解为<strong>指针，调用函数的对象</strong>，它的指向取决于函数在哪里被调用，且运行时进行绑定</p>
<h1><strong>不同调用环境中 this 的指向</strong></h1>
<h3><strong>浏览器全局环境中</strong></h3>
<p>在全局环境中执行<strong>this</strong>，表示<strong>Global</strong>对象，在浏览器中表示<strong>window</strong>对象</p>
<pre><code class="language-jsx">console.log(this); //Window
console.log(typeof this); //object
console.log(this === window); //true
</code></pre>
<h3><strong>new 运算符调用</strong></h3>
<p>当通过<strong>new</strong>运算符来调用函数时，函数被当做为一个构造函数，<strong>this 的指向构造函数创建出来的对象</strong></p>
<pre><code class="language-jsx">var name = &quot;jalever&quot;;
function A() {
  console.log(this.name);
}

A(); // jalever

var B = new A();
B(); //undefined （因为B并没有name属性）
</code></pre>
<h3>作为对象属性，<strong>非 window 环境中调用</strong></h3>
<pre><code class="language-jsx">//定义一个对象obj，添加属性name，添加方法objFun
var obj = {
  name: &quot;jalever&quot;,
  objFun: function () {
    console.log(this); // Object {name: &quot;jalever&quot;}
    console.log(typeof this); //object
    console.log(this === window); //false
    console.log(this.name); //jalever
  },
};

//调用obj对象的方法
obj.objFun(); //this 绑定到当前对象，也就是obj对象
</code></pre>
<h3>作为对象属性，<strong>window 环境中调用</strong></h3>
<pre><code class="language-jsx">//定义一个对象obj，添加属性name，添加方法objFun
var obj = {
  name: &quot;objname&quot;,
  objFun: function () {
    console.log(this); //Window
    console.log(typeof this); //object
    console.log(this === window); //true
    console.log(&quot;My name is &quot; + this.name); // My name is windowname
  },
};

var name = &quot;windowname&quot;;
var test = obj.objFun;
test();
</code></pre>
<h1><strong>解析</strong></h1>
<p>可以看出函数内部中 this 值不是静态的，是动态的，可以改变的，每次调用一个函数时，它总是在重新求值。函数内部中的 this 值，实际上是由函数被调用的父作用域提供，依赖实际函数的语法。</p>
<p>例如下面这个例子</p>
<pre><code class="language-jsx">//定义一个对象obj，添加属性name，添加方法objFun
var obj = {
  name: &quot;objname&quot;,
  objFun: function () {
    console.log(this.name);
  },
};

var name = &quot;windowname&quot;;
var test = obj.objFun;

obj.objFun(); //objname
test(); //windowname
</code></pre>
<p>第一种情况时，我们调用<strong>obj</strong>对象的方法是通过<code>obj.objFun();</code> ，此时，<strong>this</strong> 绑定到当前对象，也就是<strong>obj</strong>对象；而在第二种情况中，我们调用方法的方式是<code>var test = obj.objFun;</code> <code>test();</code>，此时，<strong>test</strong>不是一个对象的引用，所以<strong>this</strong>值代表全局对象</p>
<h1><strong>原理</strong></h1>
<p>this 的设计，跟内存里面的数据结构有关系</p>
<p><code>var obj = { foo:  5 };</code></p>
<p>上面的代码将一个对象赋值给变量<strong>obj</strong>。<strong>JavaScript</strong> 引擎会先在内存里面，生成一个对象<code>{ foo: 5 }</code>，然后把这个对象的内存地址赋值给变量<strong>obj</strong></p>
<p>也就是说，变量<strong>obj</strong>是一个地址。后面如果要读取<strong>obj.foo</strong>，引擎先从<strong>obj</strong>拿到内存地址，然后再从该地址读出原始的对象，返回它的<strong>foo</strong>属性</p>
<p>原始的对象以字典结构保存，每一个属性名都对应一个属性描述对象。举例来说，上面例子的 foo 属性，实际上是以下面的形式保存的</p>
<p><img src="/this-keyword-binding-and-mechanics/image-1.webp" alt="image-1.webp"/></p>
<p>所以当属性的值是一个函数时</p>
<p><code>var obj = { foo: function () {} };</code></p>
<p>这时，引擎会将函数单独保存在内存中，然后再将函数的地址赋值给 foo 属性的 value 属性</p>
<p><img src="/this-keyword-binding-and-mechanics/image-2.webp" alt="image-2.webp"/></p>
<p>回到我们之前的那个例子,如下:</p>
<pre><code class="language-jsx">//定义一个对象obj，添加属性name，添加方法objFun
var obj = {
  name: &#x27;objname&#x27;,
  objFun: function(){
    console.log(this。name);
  }
};

var name = &quot;windowname&quot;
var test = obj.objFun;

obj.objFun(); //objname
test(); //windowname
</code></pre>
<p>它的内存结构如下所示:</p>
<p><img src="/this-keyword-binding-and-mechanics/image-3.webp" alt="image-3.webp"/></p>
<p>所以，当我们使用<code>obj.objFun();</code>执行函数时，<strong>this.name</strong>的执行环境为<strong>obj</strong>环境；但我们使用<code>var test = obj.objFun();</code> <code>test();</code> 执行时，<strong>test</strong>已经获取到了<strong>objFun</strong>函数的存储地址了，所以它的<strong>this.name</strong>执行环境就为<strong>window</strong>环境。</p>
<h1><strong>this 的使用场景</strong></h1>
<p><img src="/this-keyword-binding-and-mechanics/image-4.webp" alt="image-4.webp"/></p>
<h1><strong>Reference</strong></h1>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&amp;mid=2651557800&amp;idx=1&amp;sn=d63af0efb5980993941bfed8b203884a&amp;chksm=80255869b752d17f24fdf9f2aff37aa846b08c55be326c696c8e2307be5f56e3e73241a9e1ba&amp;scene=126&amp;sessionid=1609851803&amp;key=8fc68d04a51ab66cfdd92bbe20c070302f864df9f7320ca7930c25e7e82d37eef739ca3436c4677f627dc5297d109198620b6adfda8481748c77418300d1bc27bbfca6c98c4191da3c29f828f67ab8f67aa2718ec072d3f0db8197b01aa89d4060a8bfdc0b25ea505d1f1727adb0aba7e913c21a1abcf3b5496c4d37e5487f1a&amp;ascene=1&amp;uin=MTUyNTM3MDAyNg%3D%3D&amp;devicetype=Windows+7+x64&amp;version=63000039&amp;lang=zh_CN&amp;exportkey=A7ePryU0J0CaUeYRFBYTT5U%3D&amp;pass_ticket=W%2By6E5PdYVGsCNogj7qBuEa5SF95IDuGr1kFSRxLPYzwK63nrR2MeDTV8NzwjvvJ&amp;wx_header=0">掌握 JavaScript 中的 this，call，apply 的原理</a></p>
<p><a href="https://www.ruanyifeng.com/blog/2018/06/javascript-this.html">JavaScript 的 this 原理</a></p></article></main></div><script src="/_next/static/chunks/webpack-008eeab58a60626f.js" async=""></script><script src="/_next/static/chunks/3949d24b-b3670977323a3ac7.js" async=""></script><script src="/_next/static/chunks/604-576b6ce5c58b6c72.js" async=""></script><script src="/_next/static/chunks/main-app-85275527660c1f16.js" async=""></script></body></html><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/a34f9d1faa5f3315-s.p.woff2\",{\"as\":\"font\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/3e50223f751b8206.css\",{\"as\":\"style\"}]\n0:\"$L3\"\n"])</script><script>self.__next_f.push([1,"4:I{\"id\":\"4518\",\"chunks\":[\"272:static/chunks/webpack-008eeab58a60626f.js\",\"508:static/chunks/3949d24b-b3670977323a3ac7.js\",\"604:static/chunks/604-576b6ce5c58b6c72.js\"],\"name\":\"\",\"async\":false}\n6:I{\"id\":\"6341\",\"chunks\":[\"272:static/chunks/webpack-008eeab58a60626f.js\",\"508:static/chunks/3949d24b-b3670977323a3ac7.js\",\"604:static/chunks/604-576b6ce5c58b6c72.js\"],\"name\":\"\",\"async\":false}\n7:I{\"id\":\"394\",\"chunks\":[\"485:static/chunks/485-3071997949e00430.js\",\"185:static/chunks/app/layout-6150dec2bf36f94b.js\"],\"name"])</script><script>self.__next_f.push([1,"\":\"ThemeProvider\",\"async\":false}\n8:I{\"id\":\"7749\",\"chunks\":[\"485:static/chunks/485-3071997949e00430.js\",\"185:static/chunks/app/layout-6150dec2bf36f94b.js\"],\"name\":\"ModeToggle\",\"async\":false}\n9:I{\"id\":\"6485\",\"chunks\":[\"485:static/chunks/485-3071997949e00430.js\",\"185:static/chunks/app/layout-6150dec2bf36f94b.js\"],\"name\":\"\",\"async\":false}\na:I{\"id\":\"9422\",\"chunks\":[\"485:static/chunks/485-3071997949e00430.js\",\"185:static/chunks/app/layout-6150dec2bf36f94b.js\"],\"name\":\"Analytics\",\"async\":false}\nb:I{\"id\":\"5813\",\"ch"])</script><script>self.__next_f.push([1,"unks\":[\"272:static/chunks/webpack-008eeab58a60626f.js\",\"508:static/chunks/3949d24b-b3670977323a3ac7.js\",\"604:static/chunks/604-576b6ce5c58b6c72.js\"],\"name\":\"\",\"async\":false}\nc:I{\"id\":\"8464\",\"chunks\":[\"272:static/chunks/webpack-008eeab58a60626f.js\",\"508:static/chunks/3949d24b-b3670977323a3ac7.js\",\"604:static/chunks/604-576b6ce5c58b6c72.js\"],\"name\":\"\",\"async\":false}\n"])</script><script>self.__next_f.push([1,"3:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/3e50223f751b8206.css\",\"precedence\":\"next\"}]],[\"$\",\"$L4\",null,{\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/posts/2021-06-20-this%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E6%8C%87%E5%90%91%E5%92%8C%E5%8E%9F%E7%90%86\",\"initialTree\":[\"\",{\"children\":[\"posts\",{\"children\":[[\"slug\",\"2021-06-20-this%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E6%8C%87%E5%90%91%E5%92%8C%E5%8E%9F%E7%90%86\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"2021-06-20-this关键字的指向和原理\\\"]}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialHead\":[\"$L5\",[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\"}]],\"globalErrorComponent\":\"$6\",\"notFound\":[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"antialiased min-h-screen bg-white dark:bg-slate-950 text-slate-900 dark:text-slate-50 __className_a184c8\",\"children\":[\"$\",\"$L7\",null,{\"attribute\":\"class\",\"defaultTheme\":\"system\",\"enableSystem\":true,\"children\":[[\"$\",\"div\",null,{\"className\":\"max-w-2xl mx-auto py-10 px-4\",\"children\":[[\"$\",\"header\",null,{\"children\":[\"$\",\"div\",null,{\"className\":\"flex items-center justify-between\",\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"nav\",null,{\"className\":\"ml-auto text-sm font-medium space-x-6\",\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/\",\"children\":\"Home\"}],[\"$\",\"$L9\",null,{\"href\":\"/about\",\"children\":\"About\"}]]}]]}]}],[\"$\",\"main\",null,{\"children\":[\"$undefined\",[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]]]}]]}],[\"$\",\"$La\",null,{}]]}]}]}],\"asNotFound\":false,\"children\":[[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"antialiased min-h-screen bg-white dark:bg-slate-950 text-slate-900 dark:text-slate-50 __className_a184c8\",\"children\":[\"$\",\"$L7\",null,{\"attribute\":\"class\",\"defaultTheme\":\"system\",\"enableSystem\":true,\"children\":[[\"$\",\"div\",null,{\"className\":\"max-w-2xl mx-auto py-10 px-4\",\"children\":[[\"$\",\"header\",null,{\"children\":[\"$\",\"div\",null,{\"className\":\"flex items-center justify-between\",\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"nav\",null,{\"className\":\"ml-auto text-sm font-medium space-x-6\",\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/\",\"children\":\"Home\"}],[\"$\",\"$L9\",null,{\"href\":\"/about\",\"children\":\"About\"}]]}]]}]}],[\"$\",\"main\",null,{\"children\":[\"$\",\"$Lb\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"template\":[\"$\",\"$Lc\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"asNotFound\":false,\"childProp\":{\"current\":[\"$\",\"$Lb\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"posts\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"template\":[\"$\",\"$Lc\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"asNotFound\":false,\"childProp\":{\"current\":[\"$\",\"$Lb\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"posts\",\"children\",[\"slug\",\"2021-06-20-this%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E6%8C%87%E5%90%91%E5%92%8C%E5%8E%9F%E7%90%86\",\"c\"],\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"template\":[\"$\",\"$Lc\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"asNotFound\":false,\"childProp\":{\"current\":[\"$Ld\",null],\"segment\":\"__PAGE__?{\\\"slug\\\":[\\\"2021-06-20-this关键字的指向和原理\\\"]}\"},\"styles\":[]}],\"segment\":[\"slug\",\"2021-06-20-this%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E6%8C%87%E5%90%91%E5%92%8C%E5%8E%9F%E7%90%86\",\"c\"]},\"styles\":[]}],\"segment\":\"posts\"},\"styles\":[]}]}]]}],[\"$\",\"$La\",null,{}]]}]}]}],null]}]]\n"])</script><script>self.__next_f.push([1,"d:[\"$\",\"article\",null,{\"className\":\"py-6 prose dark:prose-invert\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"mb-2\",\"children\":\"2021-06-20-this关键字的指向和原理\"}],[\"$\",\"p\",null,{\"className\":\"text-xl mt-0 text-slate-700 dark:text-slate-200\",\"children\":\"这篇文章深入探讨了 JavaScript 中 this 关键字的指向原理及其在不同调用环境中的行为。\"}],[\"$\",\"hr\",null,{\"className\":\"my-4\"}],[[\"$\",\"h1\",null,{\"children\":\"this 关键字的指向和原理\"}],\"\\n\",[\"$\",\"h1\",null,{\"children\":\"定义\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"this\"}],\"是\",[\"$\",\"strong\",null,{\"children\":\"JavaScript\"}],\"中的关键字，它隐式的传递了一个对象引用，可以理解为\",[\"$\",\"strong\",null,{\"children\":\"指针，调用函数的对象\"}],\"，它的指向取决于函数在哪里被调用，且运行时进行绑定\"]}],\"\\n\",[\"$\",\"h1\",null,{\"children\":[\"$\",\"strong\",null,{\"children\":\"不同调用环境中 this 的指向\"}]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":[\"$\",\"strong\",null,{\"children\":\"浏览器全局环境中\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"在全局环境中执行\",[\"$\",\"strong\",null,{\"children\":\"this\"}],\"，表示\",[\"$\",\"strong\",null,{\"children\":\"Global\"}],\"对象，在浏览器中表示\",[\"$\",\"strong\",null,{\"children\":\"window\"}],\"对象\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-jsx\",\"children\":\"console.log(this); //Window\\nconsole.log(typeof this); //object\\nconsole.log(this === window); //true\\n\"}]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":[\"$\",\"strong\",null,{\"children\":\"new 运算符调用\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"当通过\",[\"$\",\"strong\",null,{\"children\":\"new\"}],\"运算符来调用函数时，函数被当做为一个构造函数，\",[\"$\",\"strong\",null,{\"children\":\"this 的指向构造函数创建出来的对象\"}]]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-jsx\",\"children\":\"var name = \\\"jalever\\\";\\nfunction A() {\\n  console.log(this.name);\\n}\\n\\nA(); // jalever\\n\\nvar B = new A();\\nB(); //undefined （因为B并没有name属性）\\n\"}]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":[\"作为对象属性，\",[\"$\",\"strong\",null,{\"children\":\"非 window 环境中调用\"}]]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-jsx\",\"children\":\"//定义一个对象obj，添加属性name，添加方法objFun\\nvar obj = {\\n  name: \\\"jalever\\\",\\n  objFun: function () {\\n    console.log(this); // Object {name: \\\"jalever\\\"}\\n    console.log(typeof this); //object\\n    console.log(this === window); //false\\n    console.log(this.name); //jalever\\n  },\\n};\\n\\n//调用obj对象的方法\\nobj.objFun(); //this 绑定到当前对象，也就是obj对象\\n\"}]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":[\"作为对象属性，\",[\"$\",\"strong\",null,{\"children\":\"window 环境中调用\"}]]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-jsx\",\"children\":\"//定义一个对象obj，添加属性name，添加方法objFun\\nvar obj = {\\n  name: \\\"objname\\\",\\n  objFun: function () {\\n    console.log(this); //Window\\n    console.log(typeof this); //object\\n    console.log(this === window); //true\\n    console.log(\\\"My name is \\\" + this.name); // My name is windowname\\n  },\\n};\\n\\nvar name = \\\"windowname\\\";\\nvar test = obj.objFun;\\ntest();\\n\"}]}],\"\\n\",[\"$\",\"h1\",null,{\"children\":[\"$\",\"strong\",null,{\"children\":\"解析\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"可以看出函数内部中 this 值不是静态的，是动态的，可以改变的，每次调用一个函数时，它总是在重新求值。函数内部中的 this 值，实际上是由函数被调用的父作用域提供，依赖实际函数的语法。\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"例如下面这个例子\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-jsx\",\"children\":\"//定义一个对象obj，添加属性name，添加方法objFun\\nvar obj = {\\n  name: \\\"objname\\\",\\n  objFun: function () {\\n    console.log(this.name);\\n  },\\n};\\n\\nvar name = \\\"windowname\\\";\\nvar test = obj.objFun;\\n\\nobj.objFun(); //objname\\ntest(); //windowname\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"第一种情况时，我们调用\",[\"$\",\"strong\",null,{\"children\":\"obj\"}],\"对象的方法是通过\",[\"$\",\"code\",null,{\"children\":\"obj.objFun();\"}],\" ，此时，\",[\"$\",\"strong\",null,{\"children\":\"this\"}],\" 绑定到当前对象，也就是\",[\"$\",\"strong\",null,{\"children\":\"obj\"}],\"对象；而在第二种情况中，我们调用方法的方式是\",[\"$\",\"code\",null,{\"children\":\"var test = obj.objFun;\"}],\" \",[\"$\",\"code\",null,{\"children\":\"test();\"}],\"，此时，\",[\"$\",\"strong\",null,{\"children\":\"test\"}],\"不是一个对象的引用，所以\",[\"$\",\"strong\",null,{\"children\":\"this\"}],\"值代表全局对象\"]}],\"\\n\",[\"$\",\"h1\",null,{\"children\":[\"$\",\"strong\",null,{\"children\":\"原理\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"this 的设计，跟内存里面的数据结构有关系\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"var obj = { foo:  5 };\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"上面的代码将一个对象赋值给变量\",[\"$\",\"strong\",null,{\"children\":\"obj\"}],\"。\",[\"$\",\"strong\",null,{\"children\":\"JavaScript\"}],\" 引擎会先在内存里面，生成一个对象\",[\"$\",\"code\",null,{\"children\":\"{ foo: 5 }\"}],\"，然后把这个对象的内存地址赋值给变量\",[\"$\",\"strong\",null,{\"children\":\"obj\"}]]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"也就是说，变量\",[\"$\",\"strong\",null,{\"children\":\"obj\"}],\"是一个地址。后面如果要读取\",[\"$\",\"strong\",null,{\"children\":\"obj.foo\"}],\"，引擎先从\",[\"$\",\"strong\",null,{\"children\":\"obj\"}],\"拿到内存地址，然后再从该地址读出原始的对象，返回它的\",[\"$\",\"strong\",null,{\"children\":\"foo\"}],\"属性\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"原始的对象以字典结构保存，每一个属性名都对应一个属性描述对象。举例来说，上面例子的 foo 属性，实际上是以下面的形式保存的\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"$\",\"img\",null,{\"src\":\"/this-keyword-binding-and-mechanics/image-1.webp\",\"alt\":\"image-1.webp\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"所以当属性的值是一个函数时\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"var obj = { foo: function () {} };\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"这时，引擎会将函数单独保存在内存中，然后再将函数的地址赋值给 foo 属性的 value 属性\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"$\",\"img\",null,{\"src\":\"/this-keyword-binding-and-mechanics/image-2.webp\",\"alt\":\"image-2.webp\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"回到我们之前的那个例子,如下:\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-jsx\",\"children\":\"//定义一个对象obj，添加属性name，添加方法objFun\\nvar obj = {\\n  name: 'objname',\\n  objFun: function(){\\n    console.log(this。name);\\n  }\\n};\\n\\nvar name = \\\"windowname\\\"\\nvar test = obj.objFun;\\n\\nobj.objFun(); //objname\\ntest(); //windowname\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"它的内存结构如下所示:\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"$\",\"img\",null,{\"src\":\"/this-keyword-binding-and-mechanics/image-3.webp\",\"alt\":\"image-3.webp\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"所以，当我们使用\",[\"$\",\"code\",null,{\"children\":\"obj.objFun();\"}],\"执行函数时，\",[\"$\",\"strong\",null,{\"children\":\"this.name\"}],\"的执行环境为\",[\"$\",\"strong\",null,{\"children\":\"obj\"}],\"环境；但我们使用\",[\"$\",\"code\",null,{\"children\":\"var test = obj.objFun();\"}],\" \",[\"$\",\"code\",null,{\"children\":\"test();\"}],\" 执行时，\",[\"$\",\"strong\",null,{\"children\":\"test\"}],\"已经获取到了\",[\"$\",\"strong\",null,{\"children\":\"objFun\"}],\"函数的存储地址了，所以它的\",[\"$\",\"strong\",null,{\"children\":\"this.name\"}],\"执行环境就为\",[\"$\",\"strong\",null,{\"children\":\"window\"}],\"环境。\"]}],\"\\n\",[\"$\",\"h1\",null,{\"children\":[\"$\",\"strong\",null,{\"children\":\"this 的使用场景\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"$\",\"img\",null,{\"src\":\"/this-keyword-binding-and-mechanics/image-4.webp\",\"alt\":\"image-4.webp\"}]}],\"\\n\",[\"$\",\"h1\",null,{\"children\":[\"$\",\"strong\",null,{\"children\":\"Reference\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==\u0026mid=2651557800\u0026idx=1\u0026sn=d63af0efb5980993941bfed8b203884a\u0026chksm=80255869b752d17f24fdf9f2aff37aa846b08c55be326c696c8e2307be5f56e3e73241a9e1ba\u0026scene=126\u0026sessionid=1609851803\u0026key=8fc68d04a51ab66cfdd92bbe20c070302f864df9f7320ca7930c25e7e82d37eef739ca3436c4677f627dc5297d109198620b6adfda8481748c77418300d1bc27bbfca6c98c4191da3c29f828f67ab8f67aa2718ec072d3f0db8197b01aa89d4060a8bfdc0b25ea505d1f1727adb0aba7e913c21a1abcf3b5496c4d37e5487f1a\u0026ascene=1\u0026uin=MTUyNTM3MDAyNg%3D%3D\u0026devicetype=Windows+7+x64\u0026version=63000039\u0026lang=zh_CN\u0026exportkey=A7ePryU0J0CaUeYRFBYTT5U%3D\u0026pass_ticket=W%2By6E5PdYVGsCNogj7qBuEa5SF95IDuGr1kFSRxLPYzwK63nrR2MeDTV8NzwjvvJ\u0026wx_header=0\",\"children\":\"掌握 JavaScript 中的 this，call，apply 的原理\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"https://www.ruanyifeng.com/blog/2018/06/javascript-this.html\",\"children\":\"JavaScript 的 this 原理\"}]}]]]}]\n"])</script><script>self.__next_f.push([1,"5:[[[\"$\",\"meta\",null,{\"charSet\":\"utf-8\"}],[\"$\",\"title\",null,{\"children\":\"2021-06-20-this关键字的指向和原理\"}],[\"$\",\"meta\",null,{\"name\":\"description\",\"content\":\"这篇文章深入探讨了 JavaScript 中 this 关键字的指向原理及其在不同调用环境中的行为。\"}],null,null,null,null,null,null,null,null,[\"$\",\"meta\",null,{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],null,null,null,null,null,null,null,null,null,null,[]],[null,null,null,null],null,null,[null,null,null,null,null],null,null,null,null,[null,[[\"$\",\"link\",null,{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"any\"}]],[],null]]\n"])</script>