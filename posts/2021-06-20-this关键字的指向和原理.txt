1:HL["/_next/static/media/a34f9d1faa5f3315-s.p.woff2",{"as":"font","type":"font/woff2"}]
2:HL["/_next/static/css/3e50223f751b8206.css",{"as":"style"}]
0:[[["",{"children":["posts",{"children":[["slug","2021-06-20-this%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E6%8C%87%E5%90%91%E5%92%8C%E5%8E%9F%E7%90%86","c"],{"children":["__PAGE__?{\"slug\":[\"2021-06-20-this关键字的指向和原理\"]}",{}]}]}]},"$undefined","$undefined",true],"$L3",[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/3e50223f751b8206.css","precedence":"next"}]],["$L4",["$","meta",null,{"name":"next-size-adjust"}]]]]]
5:I{"id":"394","chunks":["485:static/chunks/485-3071997949e00430.js","185:static/chunks/app/layout-2e97076267892308.js"],"name":"ThemeProvider","async":false}
6:I{"id":"7749","chunks":["485:static/chunks/485-3071997949e00430.js","185:static/chunks/app/layout-2e97076267892308.js"],"name":"ModeToggle","async":false}
7:I{"id":"6485","chunks":["485:static/chunks/485-3071997949e00430.js","185:static/chunks/app/layout-2e97076267892308.js"],"name":"","async":false}
8:I{"id":"5813","chunks":["272:static/chunks/webpack-008eeab58a60626f.js","508:static/chunks/3949d24b-b3670977323a3ac7.js","604:static/chunks/604-576b6ce5c58b6c72.js"],"name":"","async":false}
9:I{"id":"8464","chunks":["272:static/chunks/webpack-008eeab58a60626f.js","508:static/chunks/3949d24b-b3670977323a3ac7.js","604:static/chunks/604-576b6ce5c58b6c72.js"],"name":"","async":false}
b:I{"id":"9422","chunks":["485:static/chunks/485-3071997949e00430.js","185:static/chunks/app/layout-2e97076267892308.js"],"name":"Analytics","async":false}
3:[["$","html",null,{"lang":"en","children":["$","body",null,{"className":"antialiased min-h-screen bg-white dark:bg-slate-950 text-slate-900 dark:text-slate-50 __className_a184c8","children":["$","$L5",null,{"attribute":"class","defaultTheme":"system","enableSystem":true,"children":[["$","div",null,{"className":"max-w-2xl mx-auto py-10 px-4","children":[["$","header",null,{"children":["$","div",null,{"className":"flex items-center justify-between","children":[["$","$L6",null,{}],["$","nav",null,{"className":"ml-auto text-sm font-medium space-x-6","children":[["$","$L7",null,{"href":"/","children":"Home"}],["$","$L7",null,{"href":"/about","children":"About"}]]}]]}]}],["$","main",null,{"children":["$","$L8",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$L9",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","asNotFound":"$undefined","childProp":{"current":["$","$L8",null,{"parallelRouterKey":"children","segmentPath":["children","posts","children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$L9",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","asNotFound":"$undefined","childProp":{"current":["$","$L8",null,{"parallelRouterKey":"children","segmentPath":["children","posts","children",["slug","2021-06-20-this%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E6%8C%87%E5%90%91%E5%92%8C%E5%8E%9F%E7%90%86","c"],"children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$L9",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","asNotFound":"$undefined","childProp":{"current":["$La",null],"segment":"__PAGE__?{\"slug\":[\"2021-06-20-this关键字的指向和原理\"]}"},"styles":[]}],"segment":["slug","2021-06-20-this%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E6%8C%87%E5%90%91%E5%92%8C%E5%8E%9F%E7%90%86","c"]},"styles":[]}],"segment":"posts"},"styles":[]}]}]]}],["$","$Lb",null,{}]]}]}]}],null]
4:[[["$","meta",null,{"charSet":"utf-8"}],["$","title",null,{"children":"2021-06-20-this关键字的指向和原理"}],["$","meta",null,{"name":"description","content":"这篇文章深入探讨了 JavaScript 中 this 关键字的指向原理及其在不同调用环境中的行为。"}],null,null,null,null,null,null,null,null,["$","meta",null,{"name":"viewport","content":"width=device-width, initial-scale=1"}],null,null,null,null,null,null,null,null,null,null,[]],[null,null,null,null],null,null,[null,null,null,null,null],null,null,null,null,[null,[["$","link",null,{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"any"}]],[],null]]
a:["$","article",null,{"className":"py-6 prose dark:prose-invert","children":[["$","h1",null,{"className":"mb-2","children":"2021-06-20-this关键字的指向和原理"}],["$","p",null,{"className":"text-xl mt-0 text-slate-700 dark:text-slate-200","children":"这篇文章深入探讨了 JavaScript 中 this 关键字的指向原理及其在不同调用环境中的行为。"}],["$","hr",null,{"className":"my-4"}],[["$","h1",null,{"children":"this 关键字的指向和原理"}],"\n",["$","h1",null,{"children":"定义"}],"\n",["$","p",null,{"children":[["$","strong",null,{"children":"this"}],"是",["$","strong",null,{"children":"JavaScript"}],"中的关键字，它隐式的传递了一个对象引用，可以理解为",["$","strong",null,{"children":"指针，调用函数的对象"}],"，它的指向取决于函数在哪里被调用，且运行时进行绑定"]}],"\n",["$","h1",null,{"children":["$","strong",null,{"children":"不同调用环境中 this 的指向"}]}],"\n",["$","h3",null,{"children":["$","strong",null,{"children":"浏览器全局环境中"}]}],"\n",["$","p",null,{"children":["在全局环境中执行",["$","strong",null,{"children":"this"}],"，表示",["$","strong",null,{"children":"Global"}],"对象，在浏览器中表示",["$","strong",null,{"children":"window"}],"对象"]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-jsx","children":"console.log(this); //Window\nconsole.log(typeof this); //object\nconsole.log(this === window); //true\n"}]}],"\n",["$","h3",null,{"children":["$","strong",null,{"children":"new 运算符调用"}]}],"\n",["$","p",null,{"children":["当通过",["$","strong",null,{"children":"new"}],"运算符来调用函数时，函数被当做为一个构造函数，",["$","strong",null,{"children":"this 的指向构造函数创建出来的对象"}]]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-jsx","children":"var name = \"jalever\";\nfunction A() {\n  console.log(this.name);\n}\n\nA(); // jalever\n\nvar B = new A();\nB(); //undefined （因为B并没有name属性）\n"}]}],"\n",["$","h3",null,{"children":["作为对象属性，",["$","strong",null,{"children":"非 window 环境中调用"}]]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-jsx","children":"//定义一个对象obj，添加属性name，添加方法objFun\nvar obj = {\n  name: \"jalever\",\n  objFun: function () {\n    console.log(this); // Object {name: \"jalever\"}\n    console.log(typeof this); //object\n    console.log(this === window); //false\n    console.log(this.name); //jalever\n  },\n};\n\n//调用obj对象的方法\nobj.objFun(); //this 绑定到当前对象，也就是obj对象\n"}]}],"\n",["$","h3",null,{"children":["作为对象属性，",["$","strong",null,{"children":"window 环境中调用"}]]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-jsx","children":"//定义一个对象obj，添加属性name，添加方法objFun\nvar obj = {\n  name: \"objname\",\n  objFun: function () {\n    console.log(this); //Window\n    console.log(typeof this); //object\n    console.log(this === window); //true\n    console.log(\"My name is \" + this.name); // My name is windowname\n  },\n};\n\nvar name = \"windowname\";\nvar test = obj.objFun;\ntest();\n"}]}],"\n",["$","h1",null,{"children":["$","strong",null,{"children":"解析"}]}],"\n",["$","p",null,{"children":"可以看出函数内部中 this 值不是静态的，是动态的，可以改变的，每次调用一个函数时，它总是在重新求值。函数内部中的 this 值，实际上是由函数被调用的父作用域提供，依赖实际函数的语法。"}],"\n",["$","p",null,{"children":"例如下面这个例子"}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-jsx","children":"//定义一个对象obj，添加属性name，添加方法objFun\nvar obj = {\n  name: \"objname\",\n  objFun: function () {\n    console.log(this.name);\n  },\n};\n\nvar name = \"windowname\";\nvar test = obj.objFun;\n\nobj.objFun(); //objname\ntest(); //windowname\n"}]}],"\n",["$","p",null,{"children":["第一种情况时，我们调用",["$","strong",null,{"children":"obj"}],"对象的方法是通过",["$","code",null,{"children":"obj.objFun();"}]," ，此时，",["$","strong",null,{"children":"this"}]," 绑定到当前对象，也就是",["$","strong",null,{"children":"obj"}],"对象；而在第二种情况中，我们调用方法的方式是",["$","code",null,{"children":"var test = obj.objFun;"}]," ",["$","code",null,{"children":"test();"}],"，此时，",["$","strong",null,{"children":"test"}],"不是一个对象的引用，所以",["$","strong",null,{"children":"this"}],"值代表全局对象"]}],"\n",["$","h1",null,{"children":["$","strong",null,{"children":"原理"}]}],"\n",["$","p",null,{"children":"this 的设计，跟内存里面的数据结构有关系"}],"\n",["$","p",null,{"children":["$","code",null,{"children":"var obj = { foo:  5 };"}]}],"\n",["$","p",null,{"children":["上面的代码将一个对象赋值给变量",["$","strong",null,{"children":"obj"}],"。",["$","strong",null,{"children":"JavaScript"}]," 引擎会先在内存里面，生成一个对象",["$","code",null,{"children":"{ foo: 5 }"}],"，然后把这个对象的内存地址赋值给变量",["$","strong",null,{"children":"obj"}]]}],"\n",["$","p",null,{"children":["也就是说，变量",["$","strong",null,{"children":"obj"}],"是一个地址。后面如果要读取",["$","strong",null,{"children":"obj.foo"}],"，引擎先从",["$","strong",null,{"children":"obj"}],"拿到内存地址，然后再从该地址读出原始的对象，返回它的",["$","strong",null,{"children":"foo"}],"属性"]}],"\n",["$","p",null,{"children":"原始的对象以字典结构保存，每一个属性名都对应一个属性描述对象。举例来说，上面例子的 foo 属性，实际上是以下面的形式保存的"}],"\n",["$","p",null,{"children":["$","img",null,{"src":"/this-keyword-binding-and-mechanics/image-1.webp","alt":"image-1.webp"}]}],"\n",["$","p",null,{"children":"所以当属性的值是一个函数时"}],"\n",["$","p",null,{"children":["$","code",null,{"children":"var obj = { foo: function () {} };"}]}],"\n",["$","p",null,{"children":"这时，引擎会将函数单独保存在内存中，然后再将函数的地址赋值给 foo 属性的 value 属性"}],"\n",["$","p",null,{"children":["$","img",null,{"src":"/this-keyword-binding-and-mechanics/image-2.webp","alt":"image-2.webp"}]}],"\n",["$","p",null,{"children":"回到我们之前的那个例子,如下:"}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-jsx","children":"//定义一个对象obj，添加属性name，添加方法objFun\nvar obj = {\n  name: 'objname',\n  objFun: function(){\n    console.log(this。name);\n  }\n};\n\nvar name = \"windowname\"\nvar test = obj.objFun;\n\nobj.objFun(); //objname\ntest(); //windowname\n"}]}],"\n",["$","p",null,{"children":"它的内存结构如下所示:"}],"\n",["$","p",null,{"children":["$","img",null,{"src":"/this-keyword-binding-and-mechanics/image-3.webp","alt":"image-3.webp"}]}],"\n",["$","p",null,{"children":["所以，当我们使用",["$","code",null,{"children":"obj.objFun();"}],"执行函数时，",["$","strong",null,{"children":"this.name"}],"的执行环境为",["$","strong",null,{"children":"obj"}],"环境；但我们使用",["$","code",null,{"children":"var test = obj.objFun();"}]," ",["$","code",null,{"children":"test();"}]," 执行时，",["$","strong",null,{"children":"test"}],"已经获取到了",["$","strong",null,{"children":"objFun"}],"函数的存储地址了，所以它的",["$","strong",null,{"children":"this.name"}],"执行环境就为",["$","strong",null,{"children":"window"}],"环境。"]}],"\n",["$","h1",null,{"children":["$","strong",null,{"children":"this 的使用场景"}]}],"\n",["$","p",null,{"children":["$","img",null,{"src":"/this-keyword-binding-and-mechanics/image-4.webp","alt":"image-4.webp"}]}],"\n",["$","h1",null,{"children":["$","strong",null,{"children":"Reference"}]}],"\n",["$","p",null,{"children":["$","a",null,{"href":"https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651557800&idx=1&sn=d63af0efb5980993941bfed8b203884a&chksm=80255869b752d17f24fdf9f2aff37aa846b08c55be326c696c8e2307be5f56e3e73241a9e1ba&scene=126&sessionid=1609851803&key=8fc68d04a51ab66cfdd92bbe20c070302f864df9f7320ca7930c25e7e82d37eef739ca3436c4677f627dc5297d109198620b6adfda8481748c77418300d1bc27bbfca6c98c4191da3c29f828f67ab8f67aa2718ec072d3f0db8197b01aa89d4060a8bfdc0b25ea505d1f1727adb0aba7e913c21a1abcf3b5496c4d37e5487f1a&ascene=1&uin=MTUyNTM3MDAyNg%3D%3D&devicetype=Windows+7+x64&version=63000039&lang=zh_CN&exportkey=A7ePryU0J0CaUeYRFBYTT5U%3D&pass_ticket=W%2By6E5PdYVGsCNogj7qBuEa5SF95IDuGr1kFSRxLPYzwK63nrR2MeDTV8NzwjvvJ&wx_header=0","children":"掌握 JavaScript 中的 this，call，apply 的原理"}]}],"\n",["$","p",null,{"children":["$","a",null,{"href":"https://www.ruanyifeng.com/blog/2018/06/javascript-this.html","children":"JavaScript 的 this 原理"}]}]]]}]
